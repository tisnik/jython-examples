<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Jython aneb poněkud opomíjený programovací jazyk pro virtuální stroj Javy</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Jython aneb poněkud opomíjený programovací jazyk pro virtuální stroj Javy</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Pro virtuální stroj programovacího jazyka Java (JVM) v&nbsp;současnosti existuje již poměrně velké množství různých &bdquo;alternativních&ldquo; programovacích jazyků. Kromě samotné Javy jakožto primárního jazyka pro JVM se setkáme především s&nbsp;trojicí oblíbených jazyků Scala, Kotlin a Groovy, za nimiž následuje Clojure, JRuby, minimálně dvě implementace JavaScriptu a v&nbsp;neposlední řadě i Jython, což je varianta Pythonu 2.x přepsaná pro JVM. A právě Jythonem, který doposud stojí poněkud v&nbsp;pozadí, se dnes budeme zabývat.</p><!--more-->



<h2>Obsah</h2>

<p><a href="#k01">1. Jython aneb poněkud opomíjený programovací jazyk pro virtuální stroj Javy</a></p>
<p><a href="#k02">2. Programovací jazyky pro JVM aneb nejde jen o Javu</a></p>
<p><a href="#k03">3. Scala</a></p>
<p><a href="#k04">4. Clojure</a></p>
<p><a href="#k05">5. Groovy</a></p>
<p><a href="#k06">6. JRuby, Jython, Rhino a Nashhorn</a></p>
<p><a href="#k07">7. Kotlin</a></p>
<p><a href="#k08">8. Další programovací jazyky portované na JVM</a></p>
<p><a href="#k09">9. Instalace Jythonu a první spuštění interpretru</a></p>
<p><a href="#k10">10. Interní nápověda</a></p>
<p><a href="#k11">11. Základní moduly dodávané společně s&nbsp;Jythonem</a></p>
<p><a href="#k12">12. Interoperabilita mezi Pythonem a Javou</a></p>
<p><a href="#k13">13. Srovnání rychlosti Pythonu 2.x, Pythonu 3.x a Jythonu při výpočtech s&nbsp;FP hodnotami</a></p>
<p><a href="#k14">14. Zdrojový kód jednoduchého benchmarku</a></p>
<p><a href="#k15">15. Skripty pro spuštění benchmarku se zvoleným interpretrem a parametry</a></p>
<p><a href="#k16">16. Výsledky prvního benchmarku</a></p>
<p><a href="#k17">17. Druhý benchmark založený na použití komplexních čísel</a></p>
<p><a href="#k18">18. Výsledky druhého benchmarku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;benchmarky i dalšími příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Jython aneb poněkud opomíjený programovací jazyk pro virtuální stroj Javy</h2>

<p>V&nbsp;dnešním článku si představíme projekt <i>Jython</i>, což je implementace dnes velmi populárního programovacího jazyka Python určená pro běh ve virtuálním stroji jazyka Java (<i>JVM &ndash; Java Virtual Machine</i>). A nejenom to &ndash; aplikace psané v&nbsp;Jythonu mohou <a href="#k12">kooperovat</a> s&nbsp;třídami a rozhraními vytvořenými v&nbsp;Javě, což je velmi výhodné, protože s&nbsp;rostoucí složitostí moderních aplikací je většinou zapotřebí mít k&nbsp;dispozici vhodný skriptovací jazyk sloužící jako &bdquo;lepidlo&ldquo; (<i>glue</i>) mezi jednotlivými bloky, z&nbsp;nichž se aplikace skládá. Jython ovšem samozřejmě není dokonalý. Jednou z&nbsp;jeho nevýhod je fakt, že je stále postaven na dnes již obstarožním Pythonu 2, druhou nevýhodou pak ta skutečnost, že se jedná o dosti pomalý jazyk, což si ostatně ukážeme na <a href="#k13">dvojici benchmarků</a>. Tato pomalost se negativně projeví zejména při výpočtech a někdy i při manipulaci s&nbsp;rozsáhlými datovými strukturami, ovšem u aplikací, v&nbsp;nichž převládají I/O operace se nemusí jednat o kritický nedostatek.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2018/04/01_jython.png"><img class="alignnone size-thumbnail wp-image-9925" src="https://mojefedora.cz/wp-content/uploads/2018/04/01_jython-394x254.png" alt="" width="394" height="254" /></a>
<p><i>Obrázek 1: Logo programovacího jazyka Jython.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Programovací jazyky pro JVM aneb nejde jen o Javu</h2>

<p>Virtuální stroj Javy (JVM), specifikace JVM a dokonce ani jeho instrukční soubor vlastně nikde striktně nepředpokládají, že JVM bude spouštět pouze bajtkód získaný překladem javovských programů. Ve specifikaci JVM je dokonce na několika místech explicitně zmíněn předpoklad, že nad virtuálním strojem Javy budou provozovány i další programovací jazyky umožňující přímý či nepřímý překlad do bajtkódu. Kromě toho je samozřejmě možné přímo v&nbsp;Javě vytvořit interpret prakticky libovolného (interpretovaného) programovacího jazyka, takže vlastně nebude velkým překvapením, když zjistíme, že dnes těchto &bdquo;JVM jazyků&ldquo; již existuje relativně velké množství. V&nbsp;následující tabulce jsou vypsány ty nejznámější a pravděpodobně nejpoužívanější jazyky, a to pro úplnost včetně samotné Javy:</p>

<table>
<tr><th>Jazyk pro JVM</th><th>Stručný popis</th><th>Odkaz</th></tr>
<tr><td>Java   </td><td>primární jazyk pro JVM, bajtkód odpovídá právě Javě</td><td><a href="https://www.oracle.com/java/index.html">https://www.oracle.com/java/index.html</a></td></tr>
<tr><td>Clojure</td><td>moderní dialekt programovacího jazyka Lisp</td><td><a href="https://clojure.org/">https://clojure.org/</a></td></tr>
<tr><td>Groovy </td><td>dynamicky typovaný jazyk pro JVM</td><td><a href="http://groovy-lang.org/">http://groovy-lang.org/</a></td></tr>
<tr><td>Rhino  </td><td>jedna z&nbsp;implementací JavaScriptu</td><td><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino">https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino</a></td></tr>
<tr><td>Nashorn</td><td>alternativní implementace JavaScriptu</td><td><a href="https://blogs.oracle.com/nashorn/">https://blogs.oracle.com/nashorn/</a></td></tr>
<tr><td>JRuby  </td><td>portace jazyka Ruby na JVM</td><td><a href="http://jruby.org/">http://jruby.org/</a></td></tr>
<tr><td>Jython </td><td>portace jazyka Python na JVM</td><td><a href="http://www.jython.org/">http://www.jython.org/</a></td></tr>
<tr><td>Kotlin </td><td>moderní staticky typovaný jazyk</td><td><a href="http://kotlinlang.org/">http://kotlinlang.org/</a></td></tr>
<tr><td>Scala  </td><td>další moderní jazyk pro JVM</td><td><a href="https://www.scala-lang.org/">https://www.scala-lang.org/</a></td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Scala</h2>

<p>Pravděpodobně nejznámějším příkladem programovacího jazyka provozovaného nad JVM je <i>Scala</i>, která nabízí prakticky bezproblémovou spolupráci mezi částmi kódu psanými ve Scale a zbytkem aplikace psaným v&nbsp;Javě (popř.&nbsp;jsou některé projekty psané pouze ve Scale, ovšem provozovány jsou například na ryze javovských serverech &ndash; Tomcat, Jetty atd.). Díky tomu, že zdrojové kódy psané ve Scale jsou přímo překládány do bajtkódu, získali tvůrci tohoto programovacího jazyka prakticky zadarmo veškeré vymoženosti, které virtuální stroj Javy (či přesněji řečeno celé JRE) poskytuje &ndash; od poměrně pečlivé kontroly bajtkódu při jeho načítání do virtuálního stroje přes použití správců paměti a JIT překladačů (<i>Just in Time Compiler</i>) až po možnost využití rozsáhlých standardních knihoven J2SE a samozřejmě taktéž mnoha dalších knihoven a frameworků, které jsou pro JVM dostupné. Ovšem Scala samozřejmě není jediným programovacím jazykem, který díky překladu do bajtkódu umožňuje využít prakticky veškerého potenciálu JVM/JRE.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2018/04/02_scala.png"><img class="alignnone size-thumbnail wp-image-9926" src="https://mojefedora.cz/wp-content/uploads/2018/04/02_scala.png" alt="" width="192" height="72" /></a>
<p><i>Obrázek 2: Logo programovacího jazyka Scala.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Clojure</h2>

<p>Z&nbsp;dalších překladačů programovacích jazyků, které pro virtuální stroj Javy vznikly, je podle mého názoru nejzajímavějším jazykem a současně i jazykem s&nbsp;velkým potenciálem pro budoucnost programovací jazyk s&nbsp;názvem <i>Clojure</i>, jehož autorem a dodnes nejaktivnějším vývojářem je Rich Hickey. Samotný název tohoto jazyka vznikl vložením písmene &bdquo;j&ldquo; (<i>Java/JVM</i>) do slova <i>closure</i> (toto slovo se používá ve smyslu &bdquo;lexikální uzávěr&ldquo; &ndash; důležitá abstrakce používaná nejenom ve funkcionálních programovacích jazycích). Velká část předností a pro mnohé vývojáře taktéž záporů programovacího jazyka Clojure vychází z&nbsp;toho, že se jedná o programovací jazyk, jehož syntaxe a sémantika do značné míry vychází z&nbsp;LISPu a Scheme, tedy jazyků známých především tím, že se v&nbsp;programech v&nbsp;nich psaných používá nadměrné množství kulatých závorek. Podrobnější informace o Clojure byly uvedeny <a href="https://www.root.cz/vyhledavani/?qs=Clojure">v&nbsp;samostatném seriálu</a>, který již vyšel na serveru <a href="http://www.root.cz">www.root.cz</a>.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2018/04/03_clojure.png"><img class="alignnone size-thumbnail wp-image-9927" src="https://mojefedora.cz/wp-content/uploads/2018/04/03_clojure-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 3: Logo programovacího jazyka Clojure.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Groovy</h2>

<p>Dalším programovacím jazykem, a nutno říci že jazykem poměrně populárním, je Groovy. Jedná se o jazyk inspirovaný některými dalšími (většinou dynamicky typovanými) programovacími jazyky, jako je Python, Ruby, ale například i Perl. Groovy podporuje objektově orientované programování a oproti Javě umožňuje psát kratší kód, z&nbsp;něhož jsou odstraněny méně podstatné části, které Java jakožto silně staticky typovaný jazyk vyžaduje. Z&nbsp;tohoto důvodu se Groovy velmi často používá všude tam, kde je vyžadovaný skriptovací jazyk běžící nad JVM. Dobrým příkladem je například konzole Jenkinsu, která <a href="https://wiki.jenkins.io/display/JENKINS/Jenkins+Script+Console">ve výchozím nastavení používá právě Groovy</a>. Podpora pro tento jazyk <a href="http://groovy-lang.org/ides.html">je součástí mnoha populárních integrovaných vývojových prostředí</a>, a to včetně IntelliJ IDEA, Netbeans i Eclipse (přes pluginy &ndash; doplňkové moduly).</p>

<a href="https://mojefedora.cz/wp-content/uploads/2018/04/04_groovy.png"><img class="alignnone size-thumbnail wp-image-9928" src="https://mojefedora.cz/wp-content/uploads/2018/04/04_groovy-513x254.png" alt="" width="513" height="254" /></a>
<p><i>Obrázek 4: Logo programovacího jazyka Groovy.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. JRuby, Jython, Rhino a Nashhorn</h2>

<p>Zatímco <i>Scala</i>, <i>Clojure</i> i <i>Groovy</i> jsou novými jazyky, které původně vznikly přímo a pouze pro potřeby programátorů používajících virtuální stroj Javy (JVM), zmíníme se v&nbsp;této kapitole alespoň ve stručnosti o jazycích &bdquo;klasických&ldquo;, které byly na JVM pouze naportovány. V&nbsp;první řadě se jedná o projekty pojmenované <a href="http://jruby.org/">JRuby</a> a <a href="http://www.jython.org/">Jython</a>, což jsou varianty jazyků Ruby a Python. Původní interpretry Ruby a Pythonu jsou naprogramovány v&nbsp;jazyku C (proto se ostatně tato varianta Pythonu nazývá CPython), JRuby a Jython jsou reimplementace pro JVM (navíc byl Python portován i na platformu .NET ve formě projektu IronPython a existuje i varianta Pythonu nazvaná PyPy naprogramovaná v&nbsp;samotném Pythonu, resp.&nbsp;přesněji řečeno v&nbsp;jeho zjednodušené variantě RPython). Na platformu JVM byl portován i programovací jazyk JavaScript, a to dokonce několikrát. Implementaci JavaScriptu zajišťují projekty <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino">Rhino</a> a Nashhorn.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2018/04/05_jruby.png"><img class="alignnone size-thumbnail wp-image-9929" src="https://mojefedora.cz/wp-content/uploads/2018/04/05_jruby.png" alt="" width="500" height="149" /></a>
<p><i>Obrázek 5: Logo programovacího jazyka JRuby.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Kotlin</h2>

<p>Posledním programovacím jazykem určeným pro běh nad virtuálním strojem Javy, o němž se dnes alespoň ve stručnosti zmíníme, je jazyk pojmenovaný <i>Kotlin</i>. Jedná se o moderní <a href="https://kotlinlang.org/">staticky typovaný programovací jazyk</a> vyvinutý ve společnosti JetBrains a jeho cíl je vlastně velmi podobný cíli, který si dal již zmíněný a poněkud starší jazyk Scala &ndash; efektivní a rychlá tvorba typově bezpečných aplikací určených pro běh nad JVM. Typovost jde ještě o krok dále, než je tomu v&nbsp;Javě, protože například rozlišuje mezi nulovatelnými a nenulovatelnými datovými typy. Na rozdíl od Scaly je však rychlost překladu zdrojových kódů naprogramovaných v&nbsp;Kotlinu rychlejší a blíží se rychlosti překladu kódů napsaných v&nbsp;samotné Javě. Kotlin podporuje různá paradigmata: objektově orientované, procedurální i funkcionální. Tomuto velmi zajímavému programovacímu jazyku se budeme věnovat v&nbsp;samostatném seriálu.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2018/04/06_kotlin.png"><img class="alignnone size-thumbnail wp-image-9930" src="https://mojefedora.cz/wp-content/uploads/2018/04/06_kotlin.png" alt="" width="152" height="151" /></a>
<p><i>Obrázek 6: Logo programovacího jazyka Kotlin.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Další programovací jazyky portované na JVM</h2>

<p>Na virtuální stroj Javy bylo portováno i mnoho dalších programovacích jazyků, ať již se jednalo o překladače či o interpretry. V&nbsp;následující tabulce jsou některé z&nbsp;těchto jazyků vypsány. V&nbsp;prvním sloupci je zobrazen název původního jazyka popř.&nbsp;rodiny jazyků, ve sloupci druhém pak jméno jeho konkrétní implementace pro JVM. Povšimněte si, že některé jazyky byly portovány několikrát (to se ostatně týkalo již JavaScriptu zmíněného <a href="#k03">ve třetí kapitole</a>):</p>

<table>
<tr><th>Jazyk</th><th>Implementace pro JVM</th></tr>
<tr><td>Ada</td><td>JGNAT</td></tr>
<tr><td>Arden Syntax</td><td>Arden2ByteCode</td></tr>
<tr><td>COBOL</td><td>Micro Focus Visual COBOL</td></tr>
<tr><td>ColdFusion Markup Language (CFML)</td><td>Adobe ColdFusion</td></tr>
<tr><td>ColdFusion Markup Language (CFML)</td><td>Railo</td></tr>
<tr><td>ColdFusion Markup Language (CFML)</td><td>Lucee</td></tr>
<tr><td>ColdFusion Markup Language (CFML)</td><td>Open BlueDragon</td></tr>
<tr><td>Common Lisp</td><td>Armed Bear Common Lisp</td></tr>
<tr><td>Cypher</td><td>Neo4j</td></tr>
<tr><td>Mercury</td><td>Mercury (Java grade)</td></tr>
<tr><td>Pascal</td><td>MIDletPascal</td></tr>
<tr><td>Pascal</td><td>Oxygene</td></tr>
<tr><td>Perl 6</td><td>Rakudo Perl 6</td></tr>
<tr><td>PHP</td><td>Quercus</td></tr>
<tr><td>Prolog</td><td>JIProlog</td></tr>
<tr><td>Prolog</td><td>TuProlog</td></tr>
<tr><td>R</td><td>Renjin</td></tr>
<tr><td>Rexx</td><td>NetRexx</td></tr>
<tr><td>Ruby</td><td>JRuby</td></tr>
<tr><td>Ruby</td><td>Mirah</td></tr>
<tr><td>Scheme</td><td>Bigloo</td></tr>
<tr><td>Scheme</td><td>Kawa</td></tr>
<tr><td>Scheme</td><td>SISC</td></tr>
<tr><td>Scheme</td><td>JScheme</td></tr>
<tr><td>Tcl</td><td>Jacl</td></tr>
<tr><td>Visual Basic</td><td>Jabaco</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Instalace Jythonu a první spuštění interpretru</h2>

<p>Instalace Jythonu je velmi jednoduchá, protože pouze postačuje si stáhnout Java archiv z&nbsp;adresy <a href="http://search.maven.org/remotecontent?filepath=org/python/jython-standalone/2.7.0/jython-standalone-2.7.0.jar">http://search.maven.org/remotecontent?filepath=org/python/jython-standalone/2.7.0/jython-standalone-2.7.0.jar</a>, například takto:</p>

<pre>
$ <strong>wget -O jython-standalone-2.7.0.jar http://search.maven.org/remotecontent?filepath=org/python/jython-standalone/2.7.0/jython-standalone-2.7.0.jar</strong>
</pre>

<p>Následně si již můžeme spustit interaktivní interpret, což se provede tímto příkazem:</p>

<pre>
$ <strong>java -jar jython-standalone-2.7.0.jar</strong>
</pre>

<p>Po několika sekundách by se měly vypsat dva řádky s&nbsp;informacemi o verzi interpretru Jythonu a o použitém virtuálním stroji Javy. Na třetím řádku se vypíše nápověda k&nbsp;některým příkazů a na řádku následujícím pak výzva (<i>prompt</i>) interpretru:</p>

<pre>
Jython 2.7.0 (default:9987c746f838, Apr 29 2015, 02:25:11) 
[OpenJDK 64-Bit Server VM (Oracle Corporation)] on java1.7.0_79
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</pre>

<p>Povšimněte si, že způsob výpisu je prakticky shodný s&nbsp;nativním CPythonem, který po spuštění taktéž vypíše tři informační řádky následované výzvou:</p>

<pre>
Python 3.4.3 (default, Nov 28 2017, 16:41:13) 
[GCC 4.8.4] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; 
</pre>

<p>Vraťme se však ke spuštěnému interpretru Jythonu. Ten se chová prakticky stejně jako klasický interpret Pythonu (CPythonu), a to včetně historie příkazového řádku, základních klávesových zkratek atd. Zkusme si například přímo v&nbsp;interpretru napsat jednoduchou programovou smyčku a otestovat tak, jak se bude měnit výzva (<i>prompt</i>) ve chvíli, kdy se změní kontext (další řádky nejsou přímo interpretovány, ale čeká se na ukončení bloku či bloků prázdným řádkem):</p>

<pre>
&gt;&gt;&gt; for i in range(10):
...     print i
... 
0
1
2
3
4
5
6
7
8
9
&gt;&gt;&gt;
</pre>

<p>Podobným způsobem se kontext přepíná i ve chvíli, kdy deklarujeme funkci (popř.&nbsp;třídu):</p>

<pre>
&gt;&gt;&gt; def max(x, y):
...     if x &gt; 0:
...         return x
...     else:
...         return y
... 
&gt;&gt;&gt; max(1,20)
1
</pre>

<p>Interpret Jythonu můžeme (na Linuxu) kdykoli opustit stiskem klávesové zkratky <strong>Ctrl+D</strong>.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2018/04/07_ide.png"><img class="alignnone size-thumbnail wp-image-9931" src="https://mojefedora.cz/wp-content/uploads/2018/04/07_ide-338x254.png" alt="" width="338" height="254" /></a>
<p><i>Obrázek 7: Podpora Jythonu v&nbsp;Eclipse s&nbsp;nainstalovaným modulem PyDev.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Interní nápověda</h2>

<p>Do interaktivní konzole jazyka Jython je integrována i nápověda, která se vyvolá velmi jednoduše zavoláním funkce <strong>help()</strong>:</p>

<pre>
&gt;&gt;&gt; help()
</pre>

<p>Po spuštění této funkce se zobrazí úvodní obrazovka s&nbsp;dalšími volbami, například &bdquo;keywords&ldquo;, &bdquo;modules&ldquo; atd. Povšimněte si, že se změnila i výzva (<i>prompt</i>) na <strong>help&gt;</strong>, což značí změnu kontextu interpretru:</p>

<pre>
Welcome to Python 2.7!  This is the online help utility.

If this is your first time using Python, you should definitely check out
the tutorial on the Internet at http://docs.python.org/2.7/tutorial/.

Enter the name of any module, keyword, or topic to get help on writing
Python programs and using Python modules.  To quit this help utility and
return to the interpreter, just type "quit".

To get a list of available modules, keywords, or topics, type "modules",
"keywords", or "topics".  Each module also comes with a one-line summary
of what it does; to list the modules whose summaries contain a given word
such as "spam", type "modules spam".
&nbsp;
help&gt;
</pre>

<p>V&nbsp;režimu nápovědy si například můžeme vypsat všechna rozpoznávaná klíčová slova:</p>

<pre>
help&gt; <strong>keywords</strong>

Here is a list of the Python keywords.  Enter any keyword to get more help.

and                 elif                if                  print
as                  else                import              raise
assert              except              in                  return
break               exec                is                  try
class               finally             lambda              while
continue            for                 not                 with
def                 from                or                  yield
del                 global              pass
</pre>

<p>Nápověda se ukončí prázdným příkazem, tj.&nbsp;stiskem klávesy <strong>Enter</strong>.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Základní moduly dodávané společně s&nbsp;Jythonem</h2>

<p>Příkazem <strong>modules</strong> si můžeme vypsat všechny moduly, které jsou dodávány společně s&nbsp;Jythonem. Ostatně i samotná existence těchto modulů je jedním z&nbsp;důvodů, proč je Java archiv Jythonu tak velký &ndash; snahou tvůrců totiž bylo zahrnout javovské varianty většiny modulů, které se v&nbsp;CPythonu velmi často používají pro tvorbu (nejenom) serverových aplikací. Ostatně sami se můžete na seznam dostupných modulů velmi snadno podívat:</p>

<pre>
BaseHTTPServer      cmath           javapath    sched
CGIHTTPServer       cmd             javashell   select
ConfigParser        code            jffi        sets
Cookie              codecs          json        sgmllib
DocXMLRPCServer     codeop          jythonlib   sha
HTMLParser          collections     keyword     shelve
MimeWriter          colorsys        linecache   shlex
Queue               command         locale      shutil
SimpleHTTPServer    commands        logging     signal
SimpleXMLRPCServer  compileall      macpath     site
SocketServer        compiler        macurl2path smtpd
StringIO            contextlib      mailbox     smtplib
UserDict            cookielib       mailcap     sndhdr
UserList            copy            markupbase  socket
UserString          copy_reg        marshal     sre
_LWPCookieJar       crypt           math        sre_compile
_MozillaCookieJar   csv             md5         sre_constants
__builtin__         ctypes          mhlib       sre_parse
__future__          datetime        mime        ssl
_abcoll             dbexts          mimetools   stat
_ast                decimal         mimetypes   string
_bytecodetools      difflib         mimify      struct
_codecs             dircache        modjy       subprocess
_collections        dis             multifile   symbol
_csv                distutils       mutex       synchronize
_fsum               doctest         netrc       sys
_functools          dom             new         sysconfig
_google_ipaddr_r234 dumbdbm         nntplib     tabnanny
_hashlib            dummy_thread    ntpath      tarfile
_imp                dummy_threading nturl2path  telnetlib
_io                 email           numbers     tempfile
_json               encodings       opcode      test
_jyio               ensurepip       operator    tests
_jythonlib          errno           optparse    textwrap
_marshal            etree           os          this
_py_compile         exceptions      parsers     thread
_pyio               filecmp         pawt        threading
_random             fileinput       pdb         time
_rawffi             fnmatch         pickle      timeit
_socket             formatter       pickletools token
_sre                fpformat        pipes       tokenize
_sslcerts           fractions       pkgutil     trace
_strptime           ftplib          platform    traceback
_systemrestart      functools       plistlib    tty
_threading          future_builtins popen2      types
_threading_local    gc              poplib      ucnhash
_weakref            genericpath     posix       unicodedata
_weakrefset         getopt          posixfile   unittest
abc                 getpass         posixpath   urllib
aifc                gettext         pprint      urllib2
anydbm              glob            profile     urlparse
argparse            grp             pstats      user
array               gzip            pty         uu
ast                 hashlib         pwd         uuid
asynchat            heapq           py_compile  warnings
asyncore            hmac            pycimport   weakref
atexit              htmlentitydefs  pyclbr      webbrowser
base64              htmllib         pydoc       whichdb
bdb                 httplib         pyexpat     wsgiref
binascii            ihooks          quopri      xdrlib
binhex              imaplib         random      xml
bisect              imghdr          re          xmllib
bz2                 imp             readline    xmlrpclib
cPickle             importlib       repr        zipfile
cStringIO           inspect         rfc822      zipimport
calendar            io              rlcompleter zlib
cgi                 isql            robotparser
cgitb               itertools       runpy
chunk               jarray          sax
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Interoperabilita mezi Pythonem a Javou</h2>

<p>Hlavním důvodem vedoucím k&nbsp;použití Jythonu je samozřejmě jeho velmi dobrá kooperace s&nbsp;Javou, tj.&nbsp;jak s&nbsp;virtuálním strojem Javy, tak i se standardními knihovnami Javy (JSE) a ostatně i s&nbsp;libovolnými dalšími knihovnami. To je velmi důležité, protože ekosystém postavený okolo JVM (a například Mavenu) je dnes velmi rozsáhlý a Jython může být v&nbsp;tomto ekosystému použit ve funkci &bdquo;lepidla&ldquo; (<i>glue</i>), které jednotlivé části dokáže spojit dohromady podle potřeb aplikace.</p>

<p>Interoperabilita mezi Pythonem a Javou je dotažena do poměrně velkých detailů, takže například v&nbsp;následujícím příkladu (spouštěném interaktivně v&nbsp;konzoli) můžeme naimportovat javovskou třídu <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Date.html">java.util.Date</a>, vytvořit její instanci a následně ji používat stejně, jako jakýkoli jiný objekt v&nbsp;Pythonu:</p>

<pre>
&gt;&gt;&gt; import java.util.Date
&gt;&gt;&gt; d = java.util.Date()
&gt;&gt;&gt; d
Sat Mar 31 18:24:14 CEST 2018
</pre>

<p>Alternativní způsob importu bude samozřejmě taktéž funkční:</p>

<pre>
&gt;&gt;&gt; from java.util import Date
&gt;&gt;&gt; d = Date()
&gt;&gt;&gt; d
Sat Mar 31 18:24:56 CEST 2018
</pre>

<p>Přístup k&nbsp;atributům objektu a volání jeho metod:</p>

<pre>
&gt;&gt;&gt; d.time
1522514182141L
&nbsp;
&gt;&gt;&gt; d.getYear()
118
</pre>

<p>Automatický převod mezi typem &bdquo;String&ldquo; v&nbsp;Javě a &bdquo;unicode&ldquo; v&nbsp;Jythonu:</p>

<pre>
&gt;&gt;&gt; from java.lang import String
&gt;&gt;&gt; s = String("42")
&nbsp;
&gt;&gt;&gt; type(s)
&lt;type 'java.lang.String'&gt;
&gt;&gt;&gt; s.toUpperCase()
u'42'
&gt;&gt;&gt; type(s.toUpperCase())
&lt;type 'unicode'&gt;
</pre>

<p>Automatická konverze mezi instancí třídy BigInteger v&nbsp;Javě a long v&nbsp;Jythonu:</p>

<pre>
&gt;&gt;&gt; import java.math.BigInteger
TypeError: java.math.BigInteger(): 1st arg can't be coerced to String, byte[]
&gt;&gt;&gt; b = java.math.BigInteger("2")
&nbsp;
&gt;&gt;&gt; type(b)
&lt;type 'java.math.BigInteger'&gt;
&gt;&gt;&gt; type(b.pow(10000))
&lt;type 'long'&gt;
&gt;&gt;&gt; type(b.multiply(b2))
&lt;type 'long'&gt;
</pre>

<p>Základ práce s&nbsp;kolekcemi:</p>

<pre>
&gt;&gt;&gt; from java.util import List, ArrayList
&gt;&gt;&gt; l = ArrayList()
&nbsp;
&gt;&gt;&gt; l.append("two")
&gt;&gt;&gt; l.append("three")
&nbsp;
&gt;&gt;&gt; l.get(1)
'three'
</pre>

<p>Při volání metod objektů, jejichž třídy byly naprogramovány v&nbsp;Javě, samozřejmě mohou vzniknout výjimky, které &bdquo;probublají&ldquo; do kódu napsaného v&nbsp;Jythonu, kde je můžeme dále zpracovat (jakoby se jednalo o výjimky vyhozené z&nbsp;Pythonovského kódu). Příkladem může být výjimka při přístupu k&nbsp;neexistujícímu prvku seznamu:</p>

<pre>
&gt;&gt;&gt; l.get(3)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
        at java.util.ArrayList.rangeCheck(ArrayList.java:635)
        at java.util.ArrayList.get(ArrayList.java:411)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
</pre>

<p>Pro zachycení javovských výjimek musíme nejdříve naimportovat příslušnou třídu:</p>

<pre>
&gt;&gt;&gt; from java.lang import IndexOutOfBoundsException
</pre>

<p>A poté již je možné výjimku snadno zachytit a zpracovat:</p>

<pre>
&gt;&gt;&gt; try:
...     l.get(3)
... except IndexOutOfBoundsException as e:
...     print e
... 
java.lang.IndexOutOfBoundsException: Index: 3, Size: 2
</pre>

<p>Podívejme se ještě, jak si můžeme snadno v&nbsp;interaktivní smyčce vypsat všechny metody nějakého objektu. Postačuje napsat jméno objektu s&nbsp;tečkou a stlačit klávesu [Tab] (ostatně podobně jako v&nbsp;interaktivních vývojových prostředích):</p>

<pre>
&gt;&gt;&gt; b.
b.ONE               b.TEN               b.ZERO              b.__class__(             b.__copy__(
b.__deepcopy__(     b.__delattr__(      b.__doc__           b.__ensure_finalizer__(  b.__eq__(
b.__format__(       b.__ge__(           b.__getattribute__( b.__gt__(                b.__hash__(
b.__init__(         b.__le__(           b.__lt__(           b.__ne__(                b.__new__(
b.__reduce__(       b.__reduce_ex__(    b.__repr__(         b.__setattr__(           b.__str__(
b.__subclasshook__( b.__unicode__(      b.abs(              b.add(                   b.and(
b.andNot(           b.bitCount(         b.bitLength(        b.byteValue(             b.class(
b.clearBit(         b.compareTo(        b.divide(           b.divideAndRemainder(    b.doubleValue(
b.equals(           b.flipBit(          b.floatValue(       b.gcd(                   b.getClass(
b.getLowestSetBit(  b.hashCode(         b.intValue(         b.isProbablePrime(       b.longValue(
b.lowestSetBit      b.max(              b.min(              b.mod(                   b.modInverse(
b.modPow(           b.multiply(         b.negate(           b.nextProbablePrime(     b.not(
b.notify(           b.notifyAll(        b.or(               b.pow(                   b.probablePrime(
b.remainder(        b.setBit(           b.shiftLeft(        b.shiftRight(            b.shortValue(
b.signum(           b.subtract(         b.testBit(          b.toByteArray(           b.toString(
b.valueOf(          b.wait(             b.xor(
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Srovnání rychlosti Pythonu 2.x, Pythonu 3.x a Jythonu při výpočtech s&nbsp;FP hodnotami</h2>

<p>Jedním z&nbsp;důvodů, proč není Jython tak populární, jako některé další programovací jazyky, které vznikly pro virtuální stroj Javy, je jeho relativně malý výpočetní výkon. Už klasický CPython ostatně velkou rychlostí neoplývá a podle <a href="https://pybenchmarks.org/u64q/jython.php">některých benchmarků</a> je Jython dokonce ještě pomalejší než CPython. Tento problém se většinou týká programů, které jsou zaměřeny na výpočty; u typických serverových aplikací s&nbsp;databází, messagingem atd. se jedná o méně závažné omezení (zde více záleží na tom, jak se nám podaří odstranit potřebu synchronizace vláken). Zkusme si nyní vytvořit dva jednoduché benchmarky určené pro porovnání rychlosti Jythonu, CPythonu 2.x a CPythonu 3.x se zaměřením na výpočty (další benchmarky se zpracováním datových struktur budou popsány příště). Všechny benchmarky byly spuštěny na Fedoře 27 a použity byly následující verze Pythonu:</p>

<ol>
<li>Jython 2.7.0</li>
<li>Python 2.7.14</li>
<li>Python 3.6.3</li>
</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. Zdrojový kód jednoduchého benchmarku</h2>

<p>Vzhledem k&nbsp;tomu, že se v&nbsp;dnešním benchmarku budeme do značné míry snažit vyhnout měření rychlosti knihovních funkcí, bude <a href="https://github.com/tisnik/jython-examples/blob/master/benchmark1/mandelbrot.py">celý benchmark</a> skutečně provádět prakticky jen výpočty s&nbsp;výpisem výsledku výpočtů na standardní výstup. Ten bude přesměrován do souboru, protože výsledkem výpočtů budou bitmapy ve formátu <i>Portable Pixel Map</i> (viz [<a href="https://www.root.cz/clanky/graficke-formaty-ve-znameni-unixu/#k06">1</a>]). Samozřejmě, že i výpis hodnot na standardní výstup znamená nutnost volání knihovních funkcí, ovšem oproti počtu numerických operací se bude jednat o minimální čas, což je možné zjistit například profilerem (to je ovšem téma, kterým se budeme zabývat v&nbsp;navazujícím článku). Celý benchmark spočívá ve výpočtu barev pixelů <a href="https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xii/">Mandelbrotovy množiny</a>, přičemž rozlišení výsledného rastrového obrázku i maximální počet iterací bude možné zvolit z&nbsp;příkazového řádku. Následuje výpis zdrojového kódu benchmarku (kód je napsán tak, aby byl kompatibilní s&nbsp;Pythonem 2.x, Pythonem 3.x i Jythonem):</p>

<pre>
import palette_mandmap
from sys import argv, exit


def calc_mandelbrot(width, height, maxiter, palette):
    print("P3")
    print("{w} {h}".format(w=width, h=height))
    print("255")

    cy = -1.5
    for y in range(0, height):
        cx = -2.0
        for x in range(0, width):
            zx = 0.0
            zy = 0.0
            i = 0
            while i &lt; maxiter:
                zx2 = zx * zx
                zy2 = zy * zy
                if zx2 + zy2 &gt; 4.0:
                    break
                zy = 2.0 * zx * zy + cy
                zx = zx2 - zy2 + cx
                i += 1

            r = palette[i][0]
            g = palette[i][1]
            b = palette[i][2]
            print("{r} {g} {b}".format(r=r, g=g, b=b))
            cx += 3.0/width
        cy += 3.0/height


if __name__ == "__main__":
    if len(argv) &lt; 4:
        print("usage: python mandelbrot width height maxiter")
        exit(1)

    width = int(argv[1])
    height = int(argv[2])
    maxiter = int(argv[3])
    calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
</pre>

<p>V&nbsp;benchmarku se používá i další modul nazvaný <strong>palette_mandmap.py</strong>, který obsahuje barvovou paletu (<i>palette, color map</i>). Paleta byla získána ze známého (a dnes již vlastně historického) programu <i>Fractint</i> a obsahuje 256 trojic hodnot R, G, B. Samotná paleta nemá prakticky žádný vliv na naměřené hodnoty, ale výsledné obrázky jsou díky ní hezčí:</p>

<pre>
# taken from Fractint
palette = (
        (255, 255, 255), (224, 224, 224), (216, 216, 216), (208, 208, 208),
        (200, 200, 200), (192, 192, 192), (184, 184, 184), (176, 176, 176),
        (168, 168, 168), (160, 160, 160), (152, 152, 152), (144, 144, 144),
        (136, 136, 136), (128, 128, 128), (120, 120, 120), (112, 112, 112),
        (104, 104, 104),  (96,  96,  96),  (88,  88,  88),  (80,  80,  80),
        (72,   72,  72),  (64,  64,  64),  (56,  56,  56),  (48,  48,  56),
        (40,   40,  56),  (32,  32,  56),  (24,  24,  56),  (16,  16,  56),
        (8,     8,  56), (000, 000,  60), (000, 000,  64), (000, 000,  72),
        (000, 000,  80), (000, 000,  88), (000, 000,  96), (000, 000, 104),
        (000, 000, 108), (000, 000, 116), (000, 000, 124), (000, 000, 132),
        (000, 000, 140), (000, 000, 148), (000, 000, 156), (000, 000, 160),
        (000, 000, 168), (000, 000, 176), (000, 000, 184), (000, 000, 192),
        (000, 000, 200), (000, 000, 204), (000, 000, 212), (000, 000, 220),
        (000, 000, 228), (000, 000, 236), (000, 000, 244), (000, 000, 252),
        (000,   4, 252),   (4,  12, 252),   (8,  20, 252),  (12,  28, 252),
        (16,   36, 252),  (20,  44, 252),  (20,  52, 252),  (24,  60, 252),
        (28,   68, 252),  (32,  76, 252),  (36,  84, 252),  (40,  92, 252),
        (40,  100, 252),  (44, 108, 252),  (48, 116, 252),  (52, 120, 252),
        (56,  128, 252),  (60, 136, 252),  (60, 144, 252),  (64, 152, 252),
        (68,  160, 252),  (72, 168, 252),  (76, 176, 252),  (80, 184, 252),
        (80,  192, 252),  (84, 200, 252),  (88, 208, 252),  (92, 216, 252),
        (96,  224, 252), (100, 232, 252), (100, 228, 248),  (96, 224, 244),
        (92,  216, 240),  (88, 212, 236),  (88, 204, 232),  (84, 200, 228),
        (80,  192, 220),  (76, 188, 216),  (76, 180, 212),  (72, 176, 208),
        (68,  168, 204),  (64, 164, 200),  (64, 156, 196),  (60, 152, 188),
        (56,  144, 184),  (52, 140, 180),  (52, 132, 176),  (48, 128, 172),
        (44,  120, 168),  (40, 116, 160),  (40, 108, 156),  (36, 104, 152),
        (32,   96, 148),  (28,  92, 144),  (28,  84, 140),  (24,  80, 136),
        (20,   72, 128),  (16,  68, 124),  (16,  60, 120),  (12,  56, 116),
        (8,    48, 112),   (4,  44, 108), (000,  36, 100),   (4,  36, 104),
        (12,   40, 108),  (16,  44, 116),  (24,  48, 120),  (28,  52, 128),
        (36,   56, 132),  (40,  60, 140),  (48,  64, 144),  (52,  64, 148),
        (60,   68, 156),  (64,  72, 160),  (72,  76, 168),  (76,  80, 172),
        (84,   84, 180),  (88,  88, 184),  (96,  92, 192), (104, 100, 192),
        (112, 112, 196), (124, 120, 200), (132, 132, 204), (144, 140, 208),
        (152, 152, 212), (164, 160, 216), (172, 172, 220), (180, 180, 224),
        (192, 192, 228), (200, 200, 232), (212, 212, 236), (220, 220, 240),
        (232, 232, 244), (240, 240, 248), (252, 252, 252), (252, 240, 244),
        (252, 224, 232), (252, 208, 224), (252, 192, 212), (252, 176, 204),
        (252, 160, 192), (252, 144, 184), (252, 128, 172), (252, 112, 164),
        (252,  96, 152), (252,  80, 144), (252,  64, 132), (252,  48, 124),
        (252,  32, 112), (252,  16, 104), (252, 000,  92), (236, 000,  88),
        (228, 000,  88), (216,   4,  84), (204,   4,  80), (192,   8,  76),
        (180,   8,  76), (168,  12,  72), (156,  16,  68), (144,  16,  64),
        (132,  20,  60), (124,  20,  60), (112,  24,  56), (100,  24,  52),
        (88,   28,  48),  (76,  32,  44),  (64,  32,  44),  (52,  36,  40),
        (40,   36,  36),  (28,  40,  32),  (16,  44,  28),  (20,  52,  32),
        (24,   60,  36),  (28,  68,  44),  (32,  76,  48),  (36,  88,  56),
        (40,   96,  60),  (44, 104,  64),  (48, 112,  72),  (52, 120,  76),
        (56,  132,  84),  (48, 136,  84),  (40, 144,  80),  (52, 148,  88),
        (68,  156, 100),  (80, 164, 112),  (96, 168, 124), (108, 176, 136),
        (124, 184, 144), (136, 192, 156), (152, 196, 168), (164, 204, 180),
        (180, 212, 192), (192, 220, 200), (208, 224, 212), (220, 232, 224),
        (236, 240, 236), (252, 248, 248), (252, 252, 252), (252, 252, 240),
        (252, 252, 228), (252, 252, 216), (248, 248, 204), (248, 248, 192),
        (248, 248, 180), (248, 248, 164), (244, 244, 152), (244, 244, 140),
        (244, 244, 128), (244, 244, 116), (240, 240, 104), (240, 240,  92),
        (240, 240,  76), (240, 240,  64), (236, 236,  52), (236, 236,  40),
        (236, 236,  28), (236, 236,  16), (232, 232,   0), (232, 232,  12),
        (232, 232,  28), (232, 232,  40), (236, 236,  56), (236, 236,  68),
        (236, 236,  84), (236, 236,  96), (240, 240, 112), (240, 240, 124),
        (240, 240, 140), (244, 244, 152), (244, 244, 168), (244, 244, 180),
        (244, 244, 196), (248, 248, 208), (248, 248, 224), (248, 248, 236),
        (252, 252, 252), (248, 248, 248), (240, 240, 240), (232, 232, 232))
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Skripty pro spuštění benchmarku se zvoleným interpretrem a parametry</h2>

<p>Pro spuštění benchmarku použijeme trojici prakticky shodných skriptů, které budou postupně zvětšovat rozlišení výsledného obrázku. Pro malý počet iterací se tedy bude spíše měřit rychlost nastartování interpretru Pythonu popř.&nbsp;virtuálního stroje Javy, ovšem u vyšších rozlišení (přibližně od 128&times;128 pixelů) již začne převládat samotná doba výpočtu a vliv startu interpretru/JVM tak bude jen marginální.</p>

<h3>Skript pro Python 2.x</h3>

<pre>
sizes="16 24 32 48 64 96 128 192 256 384 512 768 1024 1536 2048 3072 4096"

OUTFILE="python2.times"
PREFIX="python2"

rm $OUTFILE

for size in $sizes
do
    echo $size
    echo -n "$size " &gt;&gt; $OUTFILE
    /usr/bin/time --output $OUTFILE --append --format "%e %M" python2 -B mandelbrot.py $size $size 255 &gt; "${PREFIX}_${size}_${size}.ppm"
done
</pre>

<h3>Skript pro Python 3.x</h3>

<pre>
sizes="16 24 32 48 64 96 128 192 256 384 512 768 1024 1536 2048 3072 4096"

OUTFILE="python3.times"
PREFIX="python3"

rm $OUTFILE

for size in $sizes
do
    echo $size
    echo -n "$size " &gt;&gt; $OUTFILE
    /usr/bin/time --output $OUTFILE --append --format "%e %M" python3 -B mandelbrot.py $size $size 255 &gt; "${PREFIX}_${size}_${size}.ppm"
done
</pre>

<h3>Skript pro Jython</h3>

<p>Tento skript vyžaduje, aby se v&nbsp;aktuálním adresáři nacházel Java archiv s&nbsp;Jythonem popř.&nbsp;jen symbolický link na tento archiv:</p>

<pre>
sizes="16 24 32 48 64 96 128 192 256 384 512 768 1024 1536 2048 3072 4096"

OUTFILE="jython.times"
PREFIX="jython"

rm $OUTFILE

for size in $sizes
do
    echo $size
    echo -n "$size " &gt;&gt; $OUTFILE
    /usr/bin/time --output $OUTFILE --append --format "%e %M" java -jar jython-standalone-2.7.0.jar mandelbrot.py $size $size 255 &gt; "${PREFIX}_${size}_${size}.ppm"
done
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Výsledky prvního benchmarku</h2>

<p>Výsledky získané po spuštění prvního benchmarku jsou vypsány v&nbsp;následující tabulce:</p>

<p>Podívejme se nyní na slíbené výsledky:</p>

<table style="text-align:right">
<tr><th>#</th><th>x-res</th><th>y-res</th><th>Jython (s)</th><th>Python 2 (s)</th><th>Python 3 (s)</th></tr>
<tr><td>1</td><td>16</td><td>16</td><td>1.79</td><td>0.01</td><td>0.02</td></tr>
<tr><td>2</td><td>24</td><td>24</td><td>1.79</td><td>0.01</td><td>0.02</td></tr>
<tr><td>3</td><td>32</td><td>32</td><td>1.84</td><td>0.02</td><td>0.02</td></tr>
<tr><td>4</td><td>48</td><td>48</td><td>2.11</td><td>0.03</td><td>0.03</td></tr>
<tr><td>5</td><td>64</td><td>64</td><td>2.01</td><td>0.04</td><td>0.05</td></tr>
<tr><td>6</td><td>96</td><td>96</td><td>2.16</td><td>0.08</td><td>0.09</td></tr>
<tr><td>7</td><td>128</td><td>128</td><td>2.24</td><td>0.15</td><td>0.15</td></tr>
<tr><td>8</td><td>192</td><td>192</td><td>2.43</td><td>0.32</td><td>0.33</td></tr>
<tr><td>9</td><td>256</td><td>256</td><td>2.81</td><td>0.57</td><td>0.58</td></tr>
<tr><td>10</td><td>384</td><td>384</td><td>3.87</td><td>1.25</td><td>1.29</td></tr>
<tr><td>11</td><td>512</td><td>512</td><td>5.05</td><td>2.27</td><td>2.28</td></tr>
<tr><td>12</td><td>768</td><td>768</td><td>8.61</td><td>5.07</td><td>5.21</td></tr>
<tr><td>13</td><td>1024</td><td>1024</td><td>13.22</td><td>9.00</td><td>9.10</td></tr>
<tr><td>14</td><td>1536</td><td>1536</td><td>28.15</td><td>20.73</td><td>21.24</td></tr>
<tr><td>15</td><td>2048</td><td>2048</td><td>50.03</td><td>36.11</td><td>38.24</td></tr>
<tr><td>16</td><td>3072</td><td>3072</td><td>100.78</td><td>81.93</td><td>84.02</td></tr>
<tr><td>17</td><td>4096</td><td>4096</td><td>179.21</td><td>144.45</td><td>148.44</td></tr>
</table>

<a href="https://mojefedora.cz/wp-content/uploads/2018/04/08_benchmark1.png"><img class="alignnone size-thumbnail wp-image-9932" src="https://mojefedora.cz/wp-content/uploads/2018/04/08_benchmark1-292x254.png" alt="" width="292" height="254" /></a>
<p><i>Obrázek 9: Výsledky prvního benchmarku vynesené do grafu.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Druhý benchmark založený na použití komplexních čísel</h2>

<p>Vzhledem k&nbsp;tomu, že <a href="https://docs.python.org/3.5/reference/datamodel.html#the-standard-type-hierarchy">Python podporuje i práci s&nbsp;komplexními čísly</a>, si můžeme benchmark ještě více upravit, a to takovým způsobem, aby se v&nbsp;něm všechny výpočty prováděly právě nad typem <i>complex</i>. Zajímavé bude změření a porovnání rychlosti výpočtů, protože samotný virtuální stroj Javy primitivní typ &bdquo;komplexní číslo&ldquo; nezná a tím pádem ani nepodporuje. Výsledkem bude následující <a href="https://github.com/tisnik/jython-examples/blob/master/benchmark2/mandelbrot_complex.py">zdrojový kód</a>:</p>

<pre>
import palette_mandmap
from sys import argv, exit


def calc_mandelbrot(width, height, maxiter, palette):
    print("P3")
    print("{w} {h}".format(w=width, h=height))
    print("255")

    c = 0.0 - 1.5J
    for y in range(0, height):
        c = complex(-2.0, c.imag)
        for x in range(0, width):
            z = 0.0 + 0.0J
            i = 0
            while i &lt; maxiter:
                if abs(z) &gt; 4.0:
                    break
                z = z**2 + c
                i += 1

            r = palette[i][0]
            g = palette[i][1]
            b = palette[i][2]
            print("{r} {g} {b}".format(r=r, g=g, b=b))
            c += 3.0/width
        c += 3.0J/height


if __name__ == "__main__":
    if len(argv) &lt; 4:
        print("usage: python mandelbrot width height maxiter")
        exit(1)

    width = int(argv[1])
    height = int(argv[2])
    maxiter = int(argv[3])
    calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Výsledky druhého benchmarku</h2>

<p>Z&nbsp;výsledků druhého benchmarku je patrné, že je Jython při práci s&nbsp;komplexními čísly výrazně pomalejší, než nativní CPython 2.x i CPython 3.x:</p>

<table style="text-align:right">
<tr><th>#</th><th>x-res</th><th>y-res</th><th>Jython (s)</th><th>Python 2 (s)</th><th>Python 3 (s)</th></tr>
<tr><td>1 </td><td>16</td><td>16</td><td>1.77</td><td>0.01</td><td>0.02</td></tr>
<tr><td>2 </td><td>24</td><td>24</td><td>1.99</td><td>0.01</td><td>0.02</td></tr>
<tr><td>3 </td><td>32</td><td>32</td><td>1.80</td><td>0.02</td><td>0.03</td></tr>
<tr><td>4 </td><td>48</td><td>48</td><td>1.90</td><td>0.03</td><td>0.04</td></tr>
<tr><td>5 </td><td>64</td><td>64</td><td>1.99</td><td>0.04</td><td>0.06</td></tr>
<tr><td>6 </td><td>96</td><td>96</td><td>2.20</td><td>0.08</td><td>0.11</td></tr>
<tr><td>7 </td><td>128</td><td>128</td><td>2.70</td><td>0.14</td><td>0.18</td></tr>
<tr><td>8 </td><td>192</td><td>192</td><td>3.15</td><td>0.32</td><td>0.43</td></tr>
<tr><td>9 </td><td>256</td><td>256</td><td>4.13</td><td>0.56</td><td>0.77</td></tr>
<tr><td>10</td><td>384</td><td>384</td><td>6.61</td><td>1.25</td><td>1.60</td></tr>
<tr><td>11</td><td>512</td><td>512</td><td>10.10</td><td>2.22</td><td>2.71</td></tr>
<tr><td>12</td><td>768</td><td>768</td><td>20.59</td><td>5.12</td><td>6.37</td></tr>
<tr><td>13</td><td>1024</td><td>1024</td><td>34.45</td><td>9.09</td><td>10.78</td></tr>
<tr><td>14</td><td>1536</td><td>1536</td><td>77.73</td><td>20.33</td><td>24.25</td></tr>
<tr><td>15</td><td>2048</td><td>2048</td><td>134.13</td><td>35.95</td><td>43.61</td></tr>
<tr><td>16</td><td>3072</td><td>3072</td><td>294.04</td><td>81.64</td><td>99.77</td></tr>
<tr><td>17</td><td>4096</td><td>4096</td><td>523.57</td><td>148.13</td><td>176.97</td></tr>
</table>

<a href="https://mojefedora.cz/wp-content/uploads/2018/04/09_benchmark2.png"><img class="alignnone size-thumbnail wp-image-9933" src="https://mojefedora.cz/wp-content/uploads/2018/04/09_benchmark2-333x254.png" alt="" width="333" height="254" /></a>
<p><i>Obrázek 10: Výsledky druhého benchmarku vynesené do grafu.</i></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;benchmarky i dalšími příklady</h2>

<p>Oba dva jednoduché demonstrační příklady a taktéž oba benchmarky byly uloženy do Git repositáře, který naleznete na adrese <a href="https://github.com/tisnik/jython-examples">https://github.com/tisnik/jython-examples</a>. Následují odkazy na jednotlivé příklady (pro jejich spuštění je nutné mít v&nbsp;aktuálním adresáři symlink na Java archiv <strong>jython-standalone-2.7.0.jar</strong>):</p>

<h3>Úvodní příklady</h3>

<table>
<tr><th>Zdrojový kód/skript</th><th>Adresa</th></tr>
<tr><td>hello_world</td><td><a href="https://github.com/tisnik/jython-examples/blob/master/hello_world">https://github.com/tisnik/jython-examples/blob/master/benchmark2/mandelbrot_complex.py</a></td></tr>
<tr><td>java_interop</td><td><a href="https://github.com/tisnik/jython-examples/blob/master/java_interop">https://github.com/tisnik/jython-examples/blob/master/java_interop</a></td></tr>
</table>



<h3>První benchmark</h3>

<table>
<tr><th>Zdrojový kód/skript</th><th>Adresa</th></tr>
<tr><td>mandelbrot.py</td><td><a href="https://github.com/tisnik/jython-examples/blob/master/benchmark1/mandelbrot.py">https://github.com/tisnik/jython-examples/blob/master/benchmark1/mandelbrot.py</a></td></tr>
<tr><td>palette_mandmap.py</td><td><a href="https://github.com/tisnik/jython-examples/blob/master/benchmark1/palette_mandmap.py">https://github.com/tisnik/jython-examples/blob/master/benchmark1/palette_mandmap.py</a></td></tr>
<tr><td>test_jython.sh</td><td><a href="https://github.com/tisnik/jython-examples/blob/master/benchmark1/test_jython.sh">https://github.com/tisnik/jython-examples/blob/master/benchmark1/test_jython.sh</a></td></tr>
<tr><td>test_python2.sh</td><td><a href="https://github.com/tisnik/jython-examples/blob/master/benchmark1/test_python2.sh">https://github.com/tisnik/jython-examples/blob/master/benchmark1/test_python2.sh</a></td></tr>
<tr><td>test_python3.sh</td><td><a href="https://github.com/tisnik/jython-examples/blob/master/benchmark1/test_python3.sh">https://github.com/tisnik/jython-examples/blob/master/benchmark1/test_python3.sh</a></td></tr>
<tr><td>clean.sh</td><td><a href="https://github.com/tisnik/jython-examples/blob/master/benchmark1/clean.sh">https://github.com/tisnik/jython-examples/blob/master/benchmark1/clean.sh</a></td></tr>
</table>



<h3>Druhý benchmark</h3>

<table>
<tr><th>Zdrojový kód/skript</th><th>Adresa</th></tr>
<tr><td>mandelbrot_complex.py</td><td><a href="https://github.com/tisnik/jython-examples/blob/master/benchmark2/mandelbrot_complex.py">https://github.com/tisnik/jython-examples/blob/master/benchmark2/mandelbrot_complex.py</a></td></tr>
<tr><td>palette_mandmap.py</td><td><a href="https://github.com/tisnik/jython-examples/blob/master/benchmark2/palette_mandmap.py">https://github.com/tisnik/jython-examples/blob/master/benchmark2/palette_mandmap.py</a></td></tr>
<tr><td>test_jython.sh</td><td><a href="https://github.com/tisnik/jython-examples/blob/master/benchmark2/test_jython.sh">https://github.com/tisnik/jython-examples/blob/master/benchmark2/test_jython.sh</a></td></tr>
<tr><td>test_python2.sh</td><td><a href="https://github.com/tisnik/jython-examples/blob/master/benchmark2/test_python2.sh">https://github.com/tisnik/jython-examples/blob/master/benchmark2/test_python2.sh</a></td></tr>
<tr><td>test_python3.sh</td><td><a href="https://github.com/tisnik/jython-examples/blob/master/benchmark2/test_python3.sh">https://github.com/tisnik/jython-examples/blob/master/benchmark2/test_python3.sh</a></td></tr>
<tr><td>clean.sh</td><td><a href="https://github.com/tisnik/jython-examples/blob/master/benchmark2/clean.sh">https://github.com/tisnik/jython-examples/blob/master/benchmark2/clean.sh</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Stránka projektu Jython<br />
<a href="http://www.jython.org/">http://www.jython.org/</a>
</li>

<li>Jython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Jython">https://en.wikipedia.org/wiki/Jython</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>JSR 223: Scripting for the Java<sup>TM</sup> Platform<br />
<a href="https://jcp.org/en/jsr/detail?id=223">https://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>List of JVM languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">https://en.wikipedia.org/wiki/List_of_JVM_languages</a>
</li>

<li>Stránka programovacího jazyka Java<br />
<a href="https://www.oracle.com/java/index.html">https://www.oracle.com/java/index.html</a>
</li>

<li>Stránka programovacího jazyka Clojure<br />
<a href="http://clojure.org">http://clojure.org</a>
</li>

<li>Stránka programovacího jazyka Groovy<br />
<a href="http://groovy-lang.org/">http://groovy-lang.org/</a>
</li>

<li>Stránka programovacího jazyka JRuby<br />
<a href="http://jruby.org/">http://jruby.org/</a>
</li>

<li>Stránka programovacího jazyka Kotlin<br />
<a href="http://kotlinlang.org/">http://kotlinlang.org/</a>
</li>

<li>Stránka programovacího jazyka Scala<br />
<a href="https://www.scala-lang.org/">https://www.scala-lang.org/</a>
</li>

<li>Projekt Rhino<br />
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino">https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino</a>
</li>

<li>Clojure (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Clojure">https://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Groovy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Groovy_%28programming_language%29">https://en.wikipedia.org/wiki/Groovy_%28programming_language%29</a>
</li>

<li>JRuby (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/JRuby">https://en.wikipedia.org/wiki/JRuby</a>
</li>

<li>Kotlin (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Kotlin_%28programming_language%29">https://en.wikipedia.org/wiki/Kotlin_%28programming_language%29</a>
</li>

<li>Scala (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Scala_%28programming_language%29">https://en.wikipedia.org/wiki/Scala_%28programming_language%29</a>
</li>

<li>Python Interpreters Benchmarks<br />
<a href="https://pybenchmarks.org/u64q/jython.php">https://pybenchmarks.org/u64q/jython.php</a>
</li>

<li>Apache Kafka Producer Benchmarks - Java vs. Jython vs. Python<br />
<a href="http://mrafayaleem.com/2016/03/31/apache-kafka-producer-benchmarks/">http://mrafayaleem.com/2016/03/31/apache-kafka-producer-benchmarks/</a>
</li>

<li>What is Jython and is it useful at all? (Stack Overflow)<br />
<a href="https://stackoverflow.com/questions/1859865/what-is-jython-and-is-it-useful-at-all">https://stackoverflow.com/questions/1859865/what-is-jython-and-is-it-useful-at-all</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

